[TOC]



# 1. LeetCode 617

- 递归：

  - 时间复杂度：$O(n)$；

  - 空间复杂度：在最坏情况下（即 skewed tree）为$O(n)$；

- 迭代：

  - 时间复杂度：$O(n)$；
  - 空间复杂度：在最坏情况下（即 skewed tree）为$O(n)$；

- n 的含义：$n=min\{n_1, n_2\}$，其中$n_1,n_2$分别表示两棵二叉树中的节点数量；

# 2. 递归

- 对某个节点，可能出现以下4种情况：（以下用$t_1,t_2$分别表示两棵二叉树）；
  - $t_1==null,t_2==null$；
    - 返回 null；
  - $t_1!=null,t_2==null$；
    - 返回非空节点；
  - $t_1==null,t_2!=null$；
    - 返回非空节点；
  - $t_1!=null,t_2!=null$；
    - 节点值相加；
  
  - 注意：第1种情况可并入第2、3种情况中，即在第1种情况下，返回$t_1$或$t_2$均可；

```java
if (t2 == null)
	return t1;
if (t1 == null)
	return t2;
t1.val += t2.val;
```



# 3. 迭代

- 求解流程：

  - 将$t_1,t_2$中的当前节点分四种情况处理（同递归）；

  - 将$\{t_1.left, t_2.left\}$、$\{t_1.right, t_2.right\}$分别压入堆栈；

  - 每次从堆栈中弹出一组节点，分四种情况处理，直至堆栈为空；

- 为什么需要在迭代开始前添加以下代码片段？

  - A：用于处理边界条件，若$t_1$为空，则程序中的新建节点$temp$及后续节点无法与$t_1$构成连接关系；

```java
if (t1 == null)
    return t2;
```

- 新建自定义类的数组：

```java
new TreeNode[] {temp[0].left, temp[1].left};
```

