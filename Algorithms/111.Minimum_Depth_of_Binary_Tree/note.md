[TOC]



# 1. LeetCode 111

- 递归：需访问 n 个节点；

  - 时间复杂度：$O(n)$；
  - 空间复杂度：此处以递归调用的次数衡量栈的空间开销；
    - 在最好情况下，即树处于完全平衡状态，$O(log(n))$；
    - 在最坏情况下，即任一子树均处于非平衡状态，$O(n)$；
- 深度优先搜索迭代：需访问 n 个节点；

  - 时间复杂度：$O(n)$；
  - 空间复杂度：在最坏情况下，即任一子树均处于非平衡状态，$O(n)$；
- 广度优先搜索迭代：仅需访问$\frac{n}{2}$个节点；
  - 时间复杂度：$O(n)$；
  - 空间复杂度：$O(n)$；
- 备注：n 为二叉树中的节点数量；

# 2. 递归

- 求解流程：

  - 若某个节点为空，则以该节点为根节点的子树深度值为0；
- 若某个节点不为空，且该节点无子节点，则以该节点为根节点的子树深度值为1；
  - 若某个节点不为空，且该节点有子节点，则以该节点为根节点的子树深度值为两个子节点的较小深度值加1；



# 3. 深度优先搜索迭代

- 求解流程：

  - 以节点为键，以该节点的深度为值，用栈保存键值对；
  - 创建一个变量 minDepth，若当前节点无子节点，则以$min(currentDepth, minDepth)$更新该变量；
  - 若当前节点存在子节点，则将其压入堆栈，将当前深度值加1作为该子节点的深度值；
  - 不断将栈中的节点弹出，重复上述步骤，直至栈为空；



# 4. 广度优先搜索迭代

- 求解流程：
  - 与深度优先搜索的区别在于，使用队列保存键值对；